create table Calls
(
num number primary key,
date_call date,
time_call timestamp,
num_to_call number,
duration timestamp


);


drop table auditorium;
create table AUDITORIUM 
(
ID NUMBER PRIMARY KEY,
TYPE CHAR(5),
CAPACITY NUMBER
)
select * from auditorium;
insert into AUDITORIUM(id, type, capacity) values(220, 'À ', 150);
insert into AUDITORIUM(id, type, capacity) values(240, 'À ', 170);
insert into AUDITORIUM(id, type, capacity) values(260, 'À–', 8);
insert into AUDITORIUM(id, type, capacity) values(280, 'œ«', 16);
insert into AUDITORIUM(id, type, capacity) values(300, 'À–', 7);
insert into AUDITORIUM(id, type, capacity) values(320, 'À ', 80);
insert into AUDITORIUM(id, type, capacity) values(340, 'œ«', 16);

create or replace procedure aud(aud_type char)
is
startt sys_refcursor;
endd sys_refcursor;
cursor cc is select id from auditorium where type=aud_type and capacity<10;
ccc number;
myexc exception;
begin
open startt for select * from auditorium;
open cc;
fetch cc into ccc;
if cc%found then
delete  from auditorium where type=aud_type and capacity<10;
commit;
open endd for select * from auditorium;
sys.dbms_sql.return_result(startt);
sys.dbms_sql.return_result(endd);
else raise myexc;
end if;
close cc;
exception when myexc then 
dbms_output.put_line('NOFOUND');
--when others then
--dbms_output.put_line('EXC');
end aud;
execute aud('À«');




create or replace procedure spic(ii number)
is ref1 sys_refcursor;
invalid_select exception;
begin
if(ii=1) then
open ref1 for select * from auditorium where capacity<10;
sys.dbms_sql.return_result(ref1);
elsif(ii=2) then
open ref1 for select * from auditorium where capacity>=10;
sys.dbms_sql.return_result(ref1);
else raise invalid_select;
end if;
exception when invalid_select then dbms_output.put_line('INVALID');
end spic;


execute spic(2);


create table T1
(
name nvarchar2(20)
);

create table T2
(id number primary key,
name nvarchar2(10)
);

select * from T1;
drop trigger afterdelete;
insert into T1(id, name) values(1, 'A');
insert into T1(id, name) values(2, 'B');
insert into T1(id, name) values(3, 'C');
insert into T1(id, name) values(4, 'D');
insert into T1(id, name) values(5, 'E');
insert into T1(id, name) values(6, 'F');
insert into T1(id, name) values(7, 'G');
insert into T1(id, name) values(8, 'H');
insert into T1(id, name) values(9, 'J');



create or replace trigger afterdelete
after delete on t1
for each row
begin
insert into T2(id, name) values (:old.id, :old.name);
commit;
end;

delete from t1 where id=2;

select * from t1;


drop table departments;
drop table employees;
create table Employees
(employee_id number generated by default as identity primary key,
emp_name nvarchar2(20),
emp_role nvarchar2(20),
department_id number,
salary number
)
create table Departments
(department_id number generated by default as identity primary key,
dep_name nvarchar2(20),
average_salary number
)
alter table Employees add constraint de_fk foreign key (department_id) references Departments(department_id);

insert into Departments(dep_name, average_salary) values('A-DEP', 200);
insert into Departments(dep_name, average_salary) values('B-DEP', 100);
select * from departments;
select * from employees;
insert into Employees(emp_name, emp_role, department_id, salary) values('Yana', 'dev', 2, 240);
insert into Employees(emp_name, emp_role, department_id, salary) values('Vasya', 'test', 2, 120);



create or replace procedure AVERAGE_SALARY(entered_department number)
as countt number;
cc number;
cursor hello is select salary  from  employees where department_id=entered_department;
begin
open hello;
countt:=0;
dbms_output.put_line('TASK1');
fetch hello into cc;
dbms_output.put_line('TASK2');
while hello%found
loop
dbms_output.put_line('TASK3');
fetch hello into cc;
dbms_output.put_line('TASK4');
countt:=countt+cc;
dbms_output.put_line('TASK5');
dbms_output.put_line(countt);
end loop;
close hello;
update DEPARTMENTS set AVERAGE_SALARY=countt where department_id=entered_department;
commit;
dbms_output.put_line('HELLO  ' || countt  ||'    ' || cc);
exception when others then dbms_output.put_line('OOOPS');
end average_salary;

select * from employees;

execute average_salary(2);


create or replace procedure createuser(entered_name nvarchar2, entered_role nvarchar2, entered_department number)
is cursor hello is select salary from employees where department_id=entered_department and emp_role=entered_role;
choosesalary nvarchar2(20);
mysalary number;
myex exception;
begin
open hello;
fetch hello into choosesalary;
if hello%notfound then 
select average_salary into mysalary from departments where department_id=entered_department;
insert into Employees(emp_name, emp_role, department_id, salary) values(entered_name, entered_role, entered_department, mysalary);
elsif hello%found then 
insert into Employees(emp_name, emp_role, department_id, salary) values(entered_name, entered_role, entered_department, choosesalary);
else raise myex;
end if;
exception when myex then dbms_output.put_line('ERROR');
end createuser;

execute createuser('Lga', 'devv', 2);

declare num number;
begin
dbms_job.submit(job=>num, what => 'begin average_salary(2); end;', interval=> 'trunc(sysdate+1)+168/24');
commit;
end;

select * from dba_scheduler_jobs;
select * from DBA_JOBs;
begin
dbms_scheduler.create_job
(
job_name => 'j1',
job_type=>'PLSQL_BLOCK',
job_action =>'begin average_salary(2); end;',
start_date=>systimestamp+interval '604800' second,
enabled=>true
);
end;


begin
dbms_scheduler.create_job(
job_name=>'yana',
job_type=>'PLSQL_BLOCK',
job_action=>'begin null; end;',
start_date=>systimestamp+interval '5000' second,
enabled=>true
);
end;

insert into Calls(num_call, date_call, num_to_call, duration, operation) values(345, to_date('17.01.18', 'DD.MM.YY'),375,  to_date('18.01.18', 'DD.MM.YY'), 'hello');

create table Calls(
id_call number generated by default as identity primary key,
num_call number not null ,
date_call timestamp not null,
num_to_call number not null,
duration timestamp not null,
operation nvarchar2(20)
)
PARTITION BY RANGE (date_call)
INTERVAL (numtoymininterval(1, 'MONTH'))
(PARTITION p1 VALUES LESS THAN (to_date('16.01.2018', 'dd.mm.yyyy')));

drop table Calls;

create or replace trigger call
before insert on calls
for each row 
declare exc exception;
dc calls.date_call%type;
dur calls.duration%type;
cursor NOOO is select date_call, duration from calls;
begin
open NOOO;
fetch NOOO into dc, dur;
if(NOOO%found)
then
while(NOOO%found)
loop
if(:new.date_call between dc and dur) then raise exc;
rollback;
else dbms_output.put_line('OK!');
commit;
end if;
end loop;
elsif(NOOO%found)
then dbms_output.put_line('OK!))');
commit;
end if;
exception when exc then dbms_output.put_line('SORRY'); rollback;
end;



drop table Calls;
--create or replace procedure CallTo(entered_youphone number, entered_numbertocall number, entered_duration timestamp)


create table Options
(
id number generated by default as identity primary key,
option_name nvarchar2(20) default 'NO',
date_option timestamp,
old_value nvarchar2(20),
new_value nvarchar2(20)
);
drop table Options;

select * from t1;



create or replace trigger yana 
after delete or update or insert on t1
for each row
begin
if inserting then 
insert into Options(option_name, date_option, old_value, new_value) values('Insert', systimestamp, 'NULL', :new.name);
dbms_output.put_line('Insert');
elsif updating then 
insert into Options(option_name, date_option, old_value, new_value) values('Update', systimestamp, :old.name, :new.name);
dbms_output.put_line('Update');
elsif deleting then 
insert into Options(option_name, date_option, old_value, new_value) values('Delete', systimestamp, :old.name, 'NULL');
dbms_output.put_line('Delete');
end if;
end;
drop table t1;
select * from options;
insert into T1(name) values('yana');
delete from T1 where name='yyy';
update T1 set name='yanochka' where name='yana';




create or replace trigger yana_d 
before insert on calls;


declare kk number;
begin
dbms_job.submit(
job=>kk,
what=>'begin null; end;',
next_date=>trunc(sysdate+1),
interval=>'trunc(sysdate+1)+3/24');
end;
select * from user_JOBS;


begin
dbms_job.run(
job=> 23);
end;



